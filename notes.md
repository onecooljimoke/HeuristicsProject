## Definitions
- field: all 81 positions on the board
  + indices
    - row 0, column 0 can be found at index 0 of the list
    - row 1, column 0 can be found at index 9 of the list
    - ...
    - row 8, column 0 can be found at index 72 of the list
    - row 8, column 8 can be found at index 80 of the list
  + values
    - 0 = available for move
    - 1 = player 1 owns
    - 2 = player 2 owns
- macroboard (macro) list of 3x3 squares
  - indexes
    + 0 is upper left index
    + 2 is upper right index
    + 6 is lower left index
    + 8 is lower right index
  - values
    + -1 = available for move
    + 0 = the square is a draw 
    + 1 = player one won the square
    + 2 = player two won the square

## Game Engine Communication
### Input
- Space delimited
- Starts with one of three words
  + settings
    - For now we are only interested in 'settings your_botid i'
      + 'i' can be 1 or 2
    - any other settings input we can ignore for now
  + update
    - 'update game field [c,...]
      + provides a list of the current board state (see field definition above)
      + list format: c,c,c,c,....,c (length of 81)
    - 'update game macroboard [s,....]'
      + provides a list of the current macroboard state (see macroboard defn above)
      + list format: s,s,s,...s (length of 9)
    - also 'update game round i' and 'update game move i' but not interested in now
  + action
    - only one possible input starting with 'action'
    - 'action move t'
      + means it's our turn to move, initiate the move process
      + 't' is timebank in milliseconds (we can ignore the time for now)

### Output
- Will always be 'place_move i i'
  + 'i' is the row or column number of the 9 by 9 gameboard
  + 'i' is a value from 0 to 8
  + first 'i' is the column #, second is the row #

## Board Calculations
### Upper Left Corner of a Macro
- Column = (macro_# % 3) + (2 * (macro_# % 3))
- Row = floor(macro_# / 3) + (2 * floor(macro_# / 3))

### Field Index from row and column
- field index = row * 9 + col

### Row and column from field index
- Row = floor(field_index / 9)
- Column = field_index % 9

### Upper left macro row and column from row and column
- Given a row and column number caluclate the row and column of the upper left
  position of the marcoboard the original row and column belong to
- upper left macro column = 3 * floor(column / 3) 
- upper left macro row = 3 * floor(row / 3)

### Macroboard index from row and column
- macroboard index = row + (column / 3)

## Initial Goals
### Goal 1: Build a bot that can accept input, choose a random, legal move and output the move in the correct format
1. Accept from input
2. Determine the type of input 
   1. Settings
   2. Update
   3. Action
3. Determine which macroboard square a move must be made in
4. Parse the board into little squares
   - given a macroboard number, return a list of values in the
     the macroboard from left to right, top to bottom
   - for now use a single list, may worry about rows and columns later
5. Determine what squares in a macroboard are open
   - accepts a list generated by step 4
   - return a list of squares that are open
   - the list should contain values from 0 to 8 that correspond
     to indices in the passed in list 
6. Pick a move
   - input will come from the step above
   - randomly select an index value from the input 
7. Transform the selected move to a row and column in overall board
8. Output the selected move

### Program Flow
1. Input
   - (read-input)
   - settings - store both bot ids
   - update - store current board and fields
   - action - move!
   - use atoms to store values
2. Macroboard list
   - where can we move
     + (big-squares-avaiable)
   - where should we move
     + (pick-move)
     + send macroboard# to next step
3. Inside macroboard
   - where can we move?
     + (parse-macroboard)
     + (macroboard-available-cells)
   - where should we move?
     + (pick-move)
     + send index and macroboard# to output
4. Output Move
   - (convert-move-for-output)
   - (output-string)

### Goal 2: Research game strategy
1. Research tic tac toe algorithmic strategy
2. Research alpha/beta pruning
3. Research Clara rules package

